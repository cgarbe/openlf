%OpenLF Tutorial 1
======

[TOC]

# OpenLF Tutorial 1 - A First Component {#tutorial}

This tutorial will teach you how to create your first high level %OpenLF component, which operates at the clif::Dataset level.

### Overview

 The tutorial is split into three parts:
- \ref tut_new - setup build system and source
- \ref tut_comp - implementing a component
- \ref tut_use - using the component with  the @ref editor

### Prerequisites

If you haven't done so, set up clif and openlf according to [the readme](@ref install).

### Next Steps

Have a look at the [Simple image Processing Tutorial](@ref timg) or [advanced topics](@ref adv) for more component programming topics, or return to the [main index](@ref doc).

## Step 1 : Setup and Building {#tut_new}

Assuming *root* points to the source tree of openlf. At the momement external projects are not tested, so to build our first component we place a new source file in the directory *root/components/*, lets call it *tutorial.cpp*. Copy the code below into the source file. You will need to re-run cmake to get the file integrated into the build system. After running cmake you can build %OpenLF which will automatically compile the new component.

~~~~~~~~~~~~~{.cpp}
#include "clif/dataset.hpp"
#include "openlf/types.hpp"
#include "dspatch/DspPlugin.h"

#include <opencv2/highgui/highgui.hpp>

using namespace clif;
using namespace openlf;

class OpenLF_Tutorial : public DspComponent {
public:
  OpenLF_Tutorial();
  DSPCOMPONENT_TRIVIAL_CLONE(OpenLF_Tutorial);
protected:
  virtual void Process_(DspSignalBus& inputs, DspSignalBus& outputs);
private:
  LF _out;
  Dataset _out_set;
};

OpenLF_Tutorial::OpenLF_Tutorial()
{
  setTypeName_("openlf_tutorial");
  AddInput_("input");
  AddOutput_("output");
  AddParameter_("img_filename", DspParameter(DspParameter::ParamType::String));
}

void OpenLF_Tutorial::Process_(DspSignalBus& inputs, DspSignalBus& outputs)
{
  LF *in = NULL;
  cv::Mat img;
  const std::string *filename;

  errorCond(inputs.GetValue(0, in), "missing input"); RETURN_ON_ERROR

  filename = GetParameter(0)->GetString();
  errorCond(filename, "missing filename"); RETURN_ON_ERROR

  _out.data = &_out_set;
  _out_set.reset();
  _out.path = "tutorial_data";

  _out.data->memory_link(in->data);
  outputs.SetValue(0, &_out);
    
  if (!configOnly()) {
    Datastore *store = _out.data->addStore("tutorial_data", 2);
    img = cv::imread(filename->c_str(), CV_LOAD_IMAGE_GRAYSCALE);
    store->write(img);
  }
}

EXPORT_DSPCOMPONENT(OpenLF_Tutorial)

~~~~~~~~~~~~~

## Step 2 : A First Component {#tut_comp}

In the following we will go through the code step by step, explaining all parts as we go.

~~~~~~~~~~~~~{.cpp}
#include "clif/dataset.hpp"
#include "openlf/types.hpp"
#include "dspatch/DspPlugin.h"

#include <opencv2/highgui/highgui.hpp>

using namespace clif;
using namespace openlf;
~~~~~~~~~~~~~
The includes needed for our component plus *using* directives for our convenience.


~~~~~~~~~~~~~{.cpp}
class OpenLF_Tutorial : public DspComponent {
public:
  OpenLF_Tutorial();
  DSPCOMPONENT_TRIVIAL_CLONE(OpenLF_Tutorial);
protected:
  virtual void Process_(DspSignalBus& inputs, DspSignalBus& outputs);
private:
  LF _out;
  Dataset _out_set;
};
~~~~~~~~~~~~~
The *OpenLF_Tutorial* implements our new component. All components inherit from DspComponent which provides the framework necessary for graph processing:
- `DSPCOMPONENT_TRIVIAL_CLONE(OpenLF_Tutorial);` Under the hood OpenLF takes control of the components and uses *clone()* to create component instances for use within circuits, for threading etc. When using only trivially managed fields within our class (e.g. no pointers, now shared structures) we can use the *DSPCOMPONENT_TRIVIAL_CLONE* to clone our class.
- *LF _out;* and *Dataset _out_set;* provide storage for the output generated by our component. OpenLF will never delete components whose output is in use, and will create an instance of our class for each thread (if threading is used) therefore this neatly handles resorce (de)allocation without us needing to worry about threading and memory management.
The remaining parts of our class declaration will be explained below.

~~~~~~~~~~~~~{.cpp}
OpenLF_Tutorial::OpenLF_Tutorial()
{
  setTypeName_("openlf_tutorial");
  AddInput_("input");
  AddOutput_("output");
  AddParameter_("img_filename", DspParameter(DspParameter::ParamType::String));
}
~~~~~~~~~~~~~
The constructor needs to set all relevant external connection to the component.
- `setTypeName_(` sets the type name and is used to identify the component when loading a circuit from a .gml file.
- `AddInput_(`/`AddOutput_(` add an input/output with the specififed name. Add as many inputs and outputs as desired.
- `AddParameter_(` adds an Parameter with the type specified by the second argument. You can also set a default parameter with a call like this:
~~~~~~~~~~~~~{.cpp}
AddParameter_("img_filename", DspParameter(DspParameter::ParamType::String, "defaultvalue"));
AddParameter_("the_answer", DspParameter(DspParameter::ParamType::Int, 42));
~~~~~~~~~~~~~


~~~~~~~~~~~~~{.cpp}
void OpenLF_Tutorial::Process_(DspSignalBus& inputs, DspSignalBus& outputs)
{
  LF *in = NULL;
  cv::Mat img;
  const std::string *filename;
~~~~~~~~~~~~~
The virtual `Process_` method provides the actual implementation and implements error handling. The `inputs` and `outputs` are a means to communicate with the connected components. Process_ is executed in one of two modes, regular and "configuration". The configuration mode is meant as a way to check error conditions and set parameters depending on input without actually executing any heavy work. The ConfigOnly() returns true if we are currently executing a config run.

~~~~~~~~~~~~~{.cpp}
errorCond(inputs.GetValue(0, in), "missing input"); RETURN_ON_ERROR

filename = GetParameter(0)->GetString();
errorCond(filename, "missing filename"); RETURN_ON_ERROR
~~~~~~~~~~~~~
`inputs.GetValue(0, in)` stores the first input from inputs in *in* **if a connected component has stored an output of the same type**. If the connected component has not provided any output or stored an output of a different type GetValue return false.
This fact is used by `errorCond` to provide error handling. errorCond will check wether the condition supplied as first argument is true and if not set the error state of the component. Afterwards execution continues, RETURN_ON_ERROR checks the error state and takes appropiate action depending on the config state, forwarding error message to the user, but in any cases leaves Process_ immediately if there is an error. Note that errorCond accepts printf style formatting, e.g: `errorCond(cond, "too much rain: %fmm", measured_rainfall);`

~~~~~~~~~~~~~{.cpp}
...
_out.data->memory_link(in->data);
...
~~~~~~~~~~~~~
Normally when working with a clif::Dataset we want to output a copy of the dataset, together with whatever data is generated in our component. But we neither want to cause IO nor do we want actually copy a potentially large dataset (even in memory). The solution is the possibility of HDF5 (and CLIF) to create datasets in memory and to use links within datasets to transparently point to existing data. The whole magic is implemented in the memory_link() method which link a dataset against the supplied dataset, within a file existing only in memory. Subsequent writes to this dataset will happen in memory, but reads to existing data are forwarded to the original dataset. 

The rest is just wrapper code to allow the memory handling mentioned above:
~~~~~~~~~~~~~{.cpp}
_out.data = &_out_set;
_out_set.reset();
_out.path = "tutorial_data";
...
outputs.SetValue(0, &_out);
~~~~~~~~~~~~~
_out is a OpenLF::LF structure which simply points to clif::Dataset and a path within this dataset. The path is simply a hint for the next component which structure in the Dataset was changed, usefule for example to open the clifview directly at newly generated content when called from within the openlf circuit editor.
_out and _out_set are members of our component class and are reused between consecutive iterations, therefore we need to call reset() on our dataset to discard previously generated data.

Finally, with `outputs.SetValue(0, &_out);` we store a pointer to our internally allocated data in the output bus which will be consumed by the next component in the graph.

~~~~~~~~~~~~~{.cpp}
if (!configOnly()) {
  Datastore *store = _out.data->addStore("tutorial_data", 2);
  img = cv::imread(filename->c_str(), CV_LOAD_IMAGE_GRAYSCALE);
  store->write(img);
}
~~~~~~~~~~~~~
This is the actual implementation, addStore() adds a new 2D clif::Datastore to our dataset, we read the image set by the user using opencv's imread and then store the image in the Datastore. For more details on how to read/write/and process using clif see the respective documentation in the clif library.

Note that the processing is only executed if `configOnly()` returns *false*. Else processing is skipped, as configuration is executed whenever parameters or circuit connections change, to give the user a direct feedback within the OpenLF circuit editor. 

## Step 3 : Usage {#tut_use}

Simply fire up the [OpenLF Circuit Editor](@ref editor) and add three components to the default circuit: *read_clif*, *write_clif* and our new *openlf_tutorial*. Connect them, select an existing clif file for input (possibly quite large ;-) ) a new clif file for output and some image for the *img_filename* parameter. Tick the circuit and in no time  %OpenLF should generate the output file with a similar size as the input image. If you inspect the file using clifinfo of clifview (or alternatively h5list or h5dump) you will see that while all attributes were written again in the new file, all datastores are actually linked against the input file, with the exception of our newly added image. 